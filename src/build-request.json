{
  "kind": "build_request",
  "title": "Create backend RainViewer proxy + cache layer",
  "projectName": "WeatherVerse",
  "priority": "normal",
  "requirements": [
    {
      "id": "REQ-1",
      "text": "Implement a backend RainViewer integration that fetches the RainViewer public JSON metadata from `https://api.rainviewer.com/public/weather-maps.json`, normalizes it into a stable structure (host, past frames, nowcast frames, combined frames), and serves it to the frontend via a canister method so the client does not call RainViewer directly.",
      "target": "backend",
      "source": {
        "messageIds": [
          "msg-1"
        ],
        "quotes": [
          "Tek dış servis: RainViewer",
          "API key kullanılmayacak, genel public endpoint kullanılacak",
          "Client doğrudan API’ye bağlanmayacak, tüm istekler backend üzerinden geçecek"
        ]
      },
      "acceptanceCriteria": [
        "Backend exposes a public method that returns RainViewer metadata (including host and frame lists) in a consistent, validated structure.",
        "Backend uses the RainViewer public endpoint and does not require any API key.",
        "If RainViewer returns an invalid/partial payload, the backend returns a clear error (or a safe empty result) rather than trapping."
      ]
    },
    {
      "id": "REQ-2",
      "text": "Add a backend cache for the RainViewer JSON metadata with TTL=10 minutes and a lazy-refresh strategy: if cached data is still valid, return it immediately; if TTL has expired, return the last cached value immediately and trigger a single background refresh that updates the cache (avoiding duplicate refreshes).",
      "target": "backend",
      "source": {
        "messageIds": [
          "msg-1"
        ],
        "quotes": [
          "Cache süresi: 10 dakika (TTL)",
          "Lazy refresh cache stratejisi: Cache geçerliyse servis et; TTL dolduysa backend tek seferlik arka plan güncellemesi yapsın; aynı timestamp için tekrar istek yapılmasın"
        ]
      },
      "acceptanceCriteria": [
        "When called repeatedly within 10 minutes, the backend serves cached metadata without performing additional RainViewer fetches.",
        "When TTL has expired, the backend still responds quickly using the last cached value (if present) and starts at most one refresh in the background for concurrent callers.",
        "The cache stores a timestamp of when it was fetched and uses it to enforce the 10-minute TTL."
      ]
    },
    {
      "id": "REQ-3",
      "text": "Implement a backend tile proxy endpoint/method that fetches RainViewer tile PNGs on-demand from RainViewer and returns them to the frontend as bytes, so the browser never calls RainViewer directly. The proxy must support the radar tile pattern used by the client (256x256 tiles; z range 5–9) and should reject/guard invalid z/x/y values.",
      "target": "backend",
      "source": {
        "messageIds": [
          "msg-1"
        ],
        "quotes": [
          "Tile tabanlı PNG olarak gösterilecek",
          "Zoom ve pan desteği (z = 5 → 9)",
          "Client doğrudan API’ye bağlanmayacak, tüm istekler backend üzerinden geçecek"
        ]
      },
      "acceptanceCriteria": [
        "Backend provides a method that returns PNG tile bytes for a requested frame path + z/x/y (and any additional RainViewer path segments required).",
        "Requests outside allowed zoom range (5–9) are rejected (or clamped) with a clear error response.",
        "The proxy does not embed any API keys and only calls RainViewer public endpoints."
      ]
    },
    {
      "id": "REQ-4",
      "text": "Ensure the backend minimizes redundant RainViewer requests: do not re-fetch the same JSON metadata or the same tile repeatedly within the effective cache window, and prevent multiple refreshes for the same cache entry from running concurrently.",
      "target": "backend",
      "source": {
        "messageIds": [
          "msg-1"
        ],
        "quotes": [
          "aynı timestamp için tekrar istek yapılmasın",
          "zoom/pan/animasyon yeni dış API çağrısı tetiklemesin"
        ]
      },
      "acceptanceCriteria": [
        "Backend deduplicates concurrent refreshes of the JSON metadata (single in-flight refresh behavior).",
        "Backend avoids repeated outbound calls for identical tile requests when caching is enabled/feasible (at minimum, it must not cause repeated metadata calls due to tile requests)."
      ]
    },
    {
      "id": "REQ-5",
      "text": "Keep existing backend health check functionality (or provide an equivalent health check method) so the frontend/app can verify the canister is up while the new RainViewer functionality is added.",
      "target": "backend",
      "source": {
        "messageIds": [
          "msg-1"
        ],
        "quotes": [
          "Backendi oluştur"
        ]
      },
      "acceptanceCriteria": [
        "A health check method exists that returns status + version + timestamp (or equivalent), and continues to respond successfully after RainViewer features are added."
      ]
    }
  ],
  "constraints": [
    "Use English for any user-facing text.",
    "Backend must be a single Motoko actor in `backend/main.mo` (single-actor architecture).",
    "Do not require any RainViewer API key; use the public endpoint.",
    "The client must not call RainViewer directly; all RainViewer JSON and PNG tile access must go through the backend.",
    "Cache TTL for RainViewer JSON metadata must be 10 minutes."
  ],
  "nonGoals": [
    "Implementing the full frontend radar UI (map, timeline, animation) in this step.",
    "Implementing ML-based nowcasting; only backend proxy/cache is in-scope for this step.",
    "Adding third-party authentication providers (only Internet Identity is supported)."
  ],
  "imageRequirements": {
    "required": [],
    "edits": []
  },
  "userProfileUpdate": {
    "goalsToAdd": [],
    "goalsToRemove": [],
    "preferencesToAdd": [],
    "preferencesToRemove": [],
    "miscToAdd": [],
    "miscToRemove": [],
    "fieldsToSet": {},
    "fieldsToDelete": []
  }
}