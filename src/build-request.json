{
  "kind": "build_request",
  "title": "Add JSON API endpoint for Android widgets on WeatherVerse URL",
  "projectName": "WeatherVerse API",
  "priority": "normal",
  "requirements": [
    {
      "id": "REQ-4",
      "text": "Implement an HTTP JSON API in the Motoko backend so that the deployed domain https://weatherverse-gy1.caffeine.xyz/ can be used as a URL-based JSON endpoint for Android widgets (i.e., a GET request returns JSON, not HTML).",
      "target": "backend",
      "source": {
        "messageIds": [
          "msg-1"
        ],
        "quotes": [
          "https://weatherverse-gy1.caffeine.xyz/  bu URL",
          "sen kurabilir misin bunu?"
        ]
      },
      "acceptanceCriteria": [
        "A GET request to an API path (e.g., /api/weather) returns a valid JSON response body (not HTML).",
        "The backend exposes an HTTP interface (http_request) so non-browser clients (Android widgets) can fetch JSON directly via URL.",
        "Responses include appropriate Content-Type: application/json; charset=utf-8.",
        "Responses include CORS headers so the API is usable from web clients as well (e.g., Access-Control-Allow-Origin: *)."
      ]
    },
    {
      "id": "REQ-5",
      "text": "Define and serve a stable JSON schema for widget consumption that includes fields for current, daily, and weekly forecasts (matching the earlier discussed structure), and ensure the backend always returns these keys even when data is missing (using null/empty arrays rather than omitting keys).",
      "target": "backend",
      "source": {
        "messageIds": [
          "msg-1"
        ],
        "quotes": [
          "Backend’imden gelen JSON verisini parse edip widget’lere aktarmak istiyorum."
        ]
      },
      "acceptanceCriteria": [
        "The JSON response includes: city (string), current (object), daily (array), weekly (array).",
        "When no data is available, the API still returns valid JSON with empty arrays for daily/weekly and nulls or safe defaults inside current.",
        "The JSON output is deterministic and does not depend on frontend rendering."
      ]
    },
    {
      "id": "REQ-6",
      "text": "Add backend methods and storage to allow the frontend to publish (upsert) the latest weather payload that the public JSON endpoint will serve, so the API can work without relying on direct external HTTP calls from the canister.",
      "target": "backend",
      "source": {
        "messageIds": [
          "msg-1"
        ],
        "quotes": [
          "Backend’im aktif, ama ... widget’ler arka planda güncellenmiyor gibi görünüyor."
        ]
      },
      "acceptanceCriteria": [
        "Backend stores the latest published weather payload in canister state (so it persists across calls).",
        "Frontend-accessible update method exists to publish the latest weather payload (including city and forecast arrays).",
        "Public GET endpoint returns the most recently published payload.",
        "No external database is introduced."
      ]
    },
    {
      "id": "REQ-7",
      "text": "Update the React frontend to publish the currently displayed weather data to the backend whenever new weather data is fetched for a selected location, so the backend’s URL-based JSON endpoint stays fresh for Android widgets.",
      "target": "frontend",
      "source": {
        "messageIds": [
          "msg-1"
        ],
        "quotes": [
          "Şu anda hepsi ‘Veri yok’ placeholder’larını gösteriyor."
        ]
      },
      "acceptanceCriteria": [
        "When a location is selected and weather data loads successfully, the app calls the backend publish method with a payload derived from the existing useWeather() data shape.",
        "Publishing failures do not crash the UI; errors are handled gracefully (e.g., logged or shown as non-blocking status).",
        "No changes are made to files listed as immutable in SYSTEM_CONTEXT."
      ]
    },
    {
      "id": "REQ-8",
      "text": "Provide a simple health/version endpoint under /api (e.g., /api/health) that returns JSON indicating the service is running, for easy widget/network debugging.",
      "target": "backend",
      "source": {
        "messageIds": [
          "msg-1"
        ],
        "quotes": [
          "bu URL üzerinden json olarak kullanabilir miyiz"
        ]
      },
      "acceptanceCriteria": [
        "GET /api/health returns HTTP 200 with a small JSON body (e.g., {\"ok\": true, \"service\": \"WeatherVerse\"}).",
        "Content-Type is application/json; charset=utf-8.",
        "CORS headers are present."
      ]
    }
  ],
  "constraints": [
    "Keep all backend logic in the single Motoko actor at backend/main.mo (single-actor architecture).",
    "Do not edit any frontend paths listed in SYSTEM_CONTEXT.frontend.immutablePaths.",
    "Do not add external databases or non-Motoko backend services."
  ],
  "nonGoals": [
    "Implementing the Android WorkManager/AppWidgetProvider code (this project only provides the JSON endpoint).",
    "Adding third-party authentication providers (only Internet Identity is supported, and this API should remain usable by widgets via URL).",
    "Fetching Open-Meteo directly from the canister via external HTTP outcalls (the API should work via frontend-published data instead)."
  ],
  "imageRequirements": {
    "required": [],
    "edits": []
  }
}